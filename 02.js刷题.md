---
title: js刷题
date: 2024-07-10 14:42:15
permalink: /pages/9c117d/
categories:
  - 技术
  - 刷题
tags:
  - 
author: 
  name: henryboom
  link: https://github.com/henryboom
---
### **列表内容排序再渲染**

场景描述：在一个 HTML 页面中，有一个无序列表（ul），其中包含了一些项目（li）。每个项目都有一个文本内容和一个唯一的 ID。你需要编写一个 JavaScript 函数来提取列表中所有项目的文本内容，并将它们按照 ID 进行排序，然后将排序后的文本内容重新渲染回去。

代码实现：补全sortAndReturnTextContent函数，实现功能

运行sortAndReturnTextContent函数前

![img](http://battle.wicp.io:9001/blog1/202408202215406.png)

运行sortAndReturnTextContent函数后

![img](http://battle.wicp.io:9001/blog1/202408202215408.png)

~~~js
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">


</head>

<body>
  <ul id="myList">
    <li id="item1">项目 1</li>
    <li id="item3">项目 3</li>
    <li id="item2">项目 2</li>
    <li id="item4">项目 4</li>
  </ul>

  <script>
    function sortAndReturnTextContent() {
      const items = document.getElementById('myList').children;
      // 在此补全代码
      const newItems = Array.from(items).sort((a,b)=> parseInt(a.id.slice(4)) - parseInt(b.id.slice(4)));
      document.getElementById('myList').innerHTML = newItems.map(item => item.outerHTML).join('');
    }
    sortAndReturnTextContent()
  </script>
</body>

</html>
~~~

###  **文件扩展名**

要求以字符串的形式返回文件名扩展名，文件名参数为"filename"。

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        
        <script>
            const _getExFilename = (filename) => {
                // 补全代码
                //使用.分割，取最后一个元素，拼接.
                let filenameArray = filename.split('.');
                return '.'+filenameArray[filenameArray.length-1]
            }
        </script>
    </body>
</html>
~~~

### **分隔符**

##### 示例1

输入：

```
_comma(12300)
```

输出：

```
'12,300'
```

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
        /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
       

function _comma(number) {
                // 补全代码
                 if (number < 1000) {
                        return number.toString();
                    } else {
                        return _comma(Math.floor(number / 1000)) + "," + _comma(number % 1000);
                    }
            }
    </script>
</body>
</html>
~~~

### **单向绑定**

要求每当id为"input"的输入框值发生改变时触发id为"span"的标签内容同步改变。
注意：

1. 必须使用DOM0级标准事件（onchange）

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	<input id="input" type="text" onchange="change(value)"/>
        <span id="span"></span>

        <script type="text/javascript">
            // 补全代码
            //获取input的变化
            
            //监听输入的数值，进行赋值道span
            function change(value){
                const span = document.querySelector("#span")
                span.innerHTML = value
            }
                  //     document.getElementById("input").onchange = function(){
                // dom事件里的函数的this指向触发者，即input标签
                // 注意：这里不能使用箭头函数，因为箭头函数没有this指针，箭头函数的this是根据执行上下文确定的，即这里的this指向window，会报错
             //   document.getElementById("span").innerHTML = this.value
//}
        </script>
    </body>
</html>
~~~

### **创建数组**

要求返回一个长度为参数值并且每一项值都为参数值的数组。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _createArray = (number) => {
                // 补全代码
               // return Array(number).fill(number)//长度为number,元素为number
          const array = [...Array(number)].map((item)=>{
                              return number
                          })
                 
                return array
                         //  return Array.from({length:number},()=>number)//类数组转换
                //Array.from(arrayLike, mapFn, thisArg)
                //arrayLike类数组，mapFn：类似map的执行函数，迭代每个元素，thisArg：this上下文
            }
        </script>
    </body>
</html>
~~~

### 判断版本

该函数接收两个参数分别为旧版本、新版本，当新版本高于旧版本时表明需要更新，返回true，否则返回false。
注意：

1. 版本号格式均为"X.X.X"
2. X∈[0,9]
3. 当两个版本号相同时，不需要更新

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _shouldUpdate = (oldVersion, newVersion) => {
                // 补全代码
       // return Number(newVersion.replace(/\./g, '')) > Number(oldVersion.replace(/\./g, ''))
 // 先将新旧版本值 转为数组再将他们转为字符串
 //   let oldStr = oldVersion.split('.').join('') // '111' 老版本
   // let newStr = newVersion.split('.').join('') // '222' 新版本
    // 直接即可 关系操作符 如果两侧都是字符串 那么会逐个比较每一位的字符串编码
  //  return newStr > oldStr;
  return newVersion>oldVersion

            }
        </script>
    </body>
</html>
~~~

### **数组排序**

根据预设代码中的数组，实现以下功能：

1. 列表只展示数组中的name属性
2. 实现点击"销量升序"按钮，列表内容按照销量升序重新渲染
3. 实现点击"销量降序"按钮，列表内容按照销量降序重新渲染

注意：

1. 必须使用DOM0级标准事件（onclick）

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <button class='up'>销量升序</button>
        <button class='down'>销量降序</button>
        <ul></ul>

        <script>
            var cups = [
                { type: 1, price: 100, color: 'black', sales: 3000, name: '牛客logo马克杯' },
                { type: 2, price: 40, color: 'blue', sales: 1000, name: '无盖星空杯' },
                { type: 4, price: 60, color: 'green', sales: 200, name: '老式茶杯' },
                { type: 3, price: 50, color: 'green', sales: 600, name: '欧式印花杯' }
            ]
            var ul = document.querySelector('ul');
            var upbtn = document.querySelector('.up');
            var downbtn = document.querySelector('.down');
            // 补全代码
      upbtn.onclick=function() {
            cups.sort((a,b) => a.sales-b.sales)
            const str= cups.map((item,index)=>{
                return `
                    <li> ${item.name} </li>
                `
            })
            ul.innerHTML=str.join('')
        }
        downbtn.onclick =function(){
            const str = cups.map((item, index) => {
                return `
                    <li> ${item.name} </li>
                `
            })
             ul.innerHTML = str.join('')
            }
            
        </script>
    </body>
</html>
~~~

### 

### **参数解析器**

要求将字符串参数URL中的参数解析并以对象的形式返回。

##### 示例1

输入：

```
getParams('https://nowcoder.com/online?id=1&salas=1000')
```

输出：

```
{id:1, salas: 100}
```

~~~JS
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>

        <script>
            const _getParams = (url) => {
                // 补全代码
                //截取？之后的字符串
// 提取查询参数部分并将其拆分成数组
let obj = {};
  let splitUrl = url.slice(url.lastIndexOf('?') + 1).split('&'); 
 // 将每个查询参数中的 = 替换为 : 并添加引号
 splitUrl.map(element => {let [key, value] = element.split('=');
 obj[key] = value;} )
  // 将数组元素组合成一个对象形式的字符串
 //let str = `{${newArray.join(',')}}`; 
  // 使用 JSON.parse 将格式化后的 JSON 字符串解析为对象
  //let obj = JSON.parse(str);
  //return obj; // 返回解析后的对象
  //let arr = url.match(/(\w+)=(\w+)/gi);
return obj;
}
        </script>
    </body>
</html>
~~~

### 生成页码

要求根据参数动态生成"li"标签页码并插入"ul"标签下。要求如下：

1. "allItem"为总数据项个数，"pageItem"为每页的数据项个数
2. "li"标签内容为当前页码数，页码从1开始

##### 示例1

输入：

```
_createPage(13,2)
```

输出：

```
"li"长度为7，"li"内容依次为"1","2","3","4","5","6","7"
```

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	<ul id="ul">
            
        </ul>
        <script type="text/javascript">
            const _createPage = (allItem, pageItem) => {
                // 补全代码
                //这里涉及到最后一页没有存满的 情况
                //创建一个数组，长度为Math.ceil(allItem/pageItem)
                let arr = new Array(Math.ceil(allItem/pageItem)).fill(0).map((_, index) => index+1);
                //let arr = Array.from({length: Math.ceil(allItem/pageItem) }, (_, index) => index+1);

                let ul = document.querySelector('#ul')
                arr.map(e=> {
                    let li = document.createElement('li')
                    li.innerText = e
                    ul.appendChild(li)
                })
            }
        </script>
    </body>
</html>
~~~

### **总成绩排名**

要求将数组参数中的对象以总成绩(包括属性"chinese"、"math"、"english")从高到低进行排序并返回。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
        const _rank = array => {
            // 补全代码
            //不能修改原数组
           // array.map(e =>{  e.sum=e.chinese+e.math+e.english })
           //return  array.sort((a,b)=>{b.sum-a.sum})
              array.sort((left, right) => {
        let lg = left.chinese + left.math + left.english
        let rg = right.chinese + right.math + right.english
        return rg - lg
    })
    return array
        }
        </script>
    </body>
</html>
~~~

### **子字符串频次**

该函数接受两个参数分别为字符串、子字符串，要求返回子字符串在字符串中出现的频次。

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>

        <script>
            const _searchStrIndexOf = (str, target) => {
                // 补全代码
                //有可能存在ssss ss，判断不出3的情况，子串也许重叠
            //    return str.split(target).length - 1
          //        let reg=new RegExp(target,'g');
   // return str.match(reg).length;
            let index = str.indexOf(target)
            let sum = 0
            while (index > -1) {
               // indexOf表示元素第一次出现的下标
                index = str.indexOf(target, index + 1)
                sum++
                }
            return sum
            }
        </script>
    </body>
</html>
~~~

### **判断斐波那契数组**

要求以Boolean的形式返回参数数组是否为斐波那契数列。在数学上，斐波那契数列以如下方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）
注意：

1. [0,1,1]为最短有效斐波那契数列

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _isFibonacci = array => {
                // 补全代码
                 if(array.length < 3 || array[0] !== 0 || array[1] !== 1) return false
                // for(let i=2 ; i<array.length ; i++) {
               //       if(array[i] === array[i-1] + array[i-2]) continue
               //       return false
              //    }
             //     return true
             //只要有一个不符合就会返回false
            return     array.every((item, index) =>
          index < 3
            ? array[0] === 0 && array[1] === 1 && array[2] === 1
            : item === array[index - 1] + array[index - 2]
        );

            }
        </script>
    </body>
</html>
~~~

### this指向的变更

~~~js
var num1 = 1, num2 = 2;

function cal() {
    var num1 = 10, num2 = 20;
    console.log(this.num1 + this.num2);
}

var calBind = cal.bind({num1: 100, num2: 200});

new cal(); // (1)
cal(); // (2)
new calBind(); // (3)
calBind(); // (4)

~~~

#### 分析每个函数调用的结果

1. **`new cal()`**

   - 当使用 `new` 关键字调用函数时，会创建一个新的对象，并将该对象设置为函数调用中的 `this` 值。
   - 因此，在 `new cal()` 调用中，`this` 指向一个新创建的对象，它没有 `num1` 和 `num2` 属性。
   - 代码中的局部变量 `num1` 和 `num2` 并不影响 `this.num1` 和 `this.num2`。
   - 所以 `this.num1` 和 `this.num2` 都是 `undefined`。
   - `undefined + undefined` 结果为 `NaN`。

   ```javascript
   new cal(); // 输出 NaN
   ```

2. **`cal()`**

   - 直接调用函数时，`this` 默认指向全局对象（在浏览器中为 `window`，在 Node.js 中为 `global`），因为我们不是严格模式。
   - 在全局对象中，`num1` 和 `num2` 分别为 `1` 和 `2`。
   - 因此，`this.num1` 是 `1`，`this.num2` 是 `2`。

   ```javascript
   cal(); // 输出 3
   ```

3. **`new calBind()`**

   - `calBind` 是通过 `Function.prototype.bind` 创建的新函数，`this` 永久绑定到 `{num1: 100, num2: 200}`。
   - 然而，使用 `new` 关键字调用 `calBind` 时，会创建一个新的对象，并将其设置为 `this`。
   - 根据 `bind` 的行为，在使用 `new` 时，绑定的 `this` 会被忽略。
   - 由于 `cal` 函数中的局部变量 `num1` 和 `num2` 不影响新创建对象的 `this.num1` 和 `this.num2`，它们都是 `undefined`。

   ```javascript
   new calBind(); // 输出 NaN
   ```

4. **`calBind()`**

   - `calBind` 调用时，`this` 已经被绑定到 `{num1: 100, num2: 200}`。
   - 因此，`this.num1` 是 `100`，`this.num2` 是 `200`。

   ```javascript
   calBind(); // 输出 300
   ```

#### 总结

- `new cal()` 输出：`NaN`
- `cal()` 输出：`3`
- `new calBind()` 输出：`NaN`
- `calBind()` 输出：`300`

这是因为 `this` 在每种调用方式下的指向不同，影响了对 `num1` 和 `num2` 的访问。

### **JS29** **全选**

请补全JavaScript代码，实现以下效果：

1. 选中"全选"框，以下所有选项全部勾选。
2. 把"全选"框从选中状态勾选成未选中状态，其他复选框全部取消选中效果。
3. 当其他复选框全部选中，"全选框"为选中状态。
4. 当其他复选框有一个未选中，"全选框"取消选中状态。

注意：

1. 必须使用DOM0级标准事件（onchange）

~~~js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
</head>
<style>
    ul {
        list-style: none;
    }
</style>

<body>

    <ul>
        <li>全选<input type='checkbox' id='all'></li>
        <li>Java<input type='checkbox' class='item'></li>
        <li>javaScript<input type='checkbox' class='item'></li>
        <li>C++<input type='checkbox' class='item'></li>
        <li>python<input type='checkbox' class='item'></li>
        <li>.net<input type='checkbox' class='item'></li>
    </ul>

    <script>
        // 补全代码
            var  all = document.querySelector('#all')

            var  options = Array.from(document.querySelectorAll('.item'))

            all.onchange= ()=>{
                options.forEach(x=>x.checked = all.checked)
            }

            options.forEach(item=>{
                item.onchange = () =>{
                    all.checked = options.every(x=>x.checked)
                }
            })

    </script>
</body>

</html>

~~~

### **Proxy计数器**

请补全JavaScript代码，请给参数对象添加拦截代理功能，并返回这个代理，要求每当通过代理调用该对象拥有的属性时，"count"值加1，否则减1。

~~~js
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Proxy Example</title>
</head>
<body>
     <!-- // 示例对象
        const myObject = { a: 1, b: 2 };

        // 使用 _proxy 函数创建 myObject 的代理
        const proxiedObject = _proxy(myObject);

        // 访问属性并查看计数器的变化
        console.log(proxiedObject.a); // 输出: 1, count 变为 1
        console.log(proxiedObject.b); // 输出: 2, count 变为 2
        console.log(proxiedObject.c); // 输出: undefined, count 变为 1
        console.log(count); // 最终输出: 1 -->
    <!-- Proxy 虽然 是代理，但是本质还是对原对象进行操作，所以要结合Reflect使用，才是真正的不再对原对象进行直接操作
而且Reflect有返回值 -->
    <script type="text/javascript">
        // 初始化计数器
        let count = 0;

        // 定义一个函数，用于创建对象的代理
        const _proxy = object => {
            // 创建代理对象，拦截对原始对象的操作
            const objectProxy = new Proxy(object, {
                // 拦截对属性的获取操作
                get(target, prop, receiver) {
                    // 尝试从原始对象中获取属性值
                    const isSuccss = Reflect.get(target, prop, receiver);

                    // 如果属性存在于目标对象中
                    if (prop in target) {
                        count++; // 增加计数器
                    } else {
                        count--; // 减少计数器
                    }

                    // 返回获取的属性值
                    return isSuccss;
                }
            });
            // 返回代理对象
            return objectProxy;
        }
 
      
    </script>
</body>
</html>

~~~

### 获取页面所有a标签，判断链接的协议是否是https

~~~js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Check HTTPS Links</title>
</head>
<body>
    <a href="https://example.com">Example HTTPS</a>
    <a href="http://example.com">Example HTTP</a>
    <a href="#section">Internal Link</a>

    <script>
        document.querySelectorAll('a').forEach(anchor => {
            if (anchor.href.startsWith('https://')) {
                console.log(`${anchor.href} uses HTTPS`);
            } else {
                console.log(`${anchor.href} does not use HTTPS`);
            }
        });
    </script>
</body>
</html>

~~~

### 敏感信息隐藏

~~~js
// 将字符串中间四个字符隐藏为传入的字符，默认为*
// 1. 字符串长度小于等于4，返回字符串长度对应的*，如"1234" => "****"
// 2. 若字符串长度为奇数，隐藏中间四个字符，多出来的一个数放后面，如"123456789" => "12****789"
// 3. 若字符串长度为偶数，隐藏中间四个字符，如"12345678" => "12****78"

//方法一：直接寻找字符串的需要修改的地方，进行截取拼接
function hideMiddleChars(str, hideChar = '*') {
    const len = str.length;
    
    if (len <= 4) {
        return hideChar.repeat(len);
    }
    
    const middleIndex = Math.floor(len / 2); // 中间位置索引
    
    // 获取隐藏的前后各两位字符的位置
    const start = middleIndex - 2;
    const end = middleIndex + 2;
    
    // 拼接隐藏中间四个字符的字符串
    const hiddenStr = str.substring(0, start) + hideChar.repeat(4) + str.substring(end);
    
    return hiddenStr;
}
//方法二：转换为数组，使用瑞士军刀splice
function hideMiddleChars(str, hideChar = '*') {
    const len = str.length;
    if (len <= 4) {
        return hideChar.repeat(len);
    }
    // 将字符串转换为数组
    let strArr = str.split('');
    const middleIndex = Math.floor(len / 2);
    // 确定起始和结束位置
    const start = middleIndex - 2;
    
    // 使用 splice 替换中间四个字符为 hideChar
    strArr.splice(start, 4, ...Array(4).fill(hideChar));
    
    // 将数组重新拼接成字符串
    const hiddenStr = strArr.join('');
    
    return hiddenStr;
}

console.log(hideMiddleChars("1234")); // "****"
console.log(hideMiddleChars("123456789")); // "12****789"
console.log(hideMiddleChars("12345678")); // "12****78"
console.log(hideMiddleChars("123456")); // "1****6"
console.log(hideMiddleChars("1")); // "*"
console.log(hideMiddleChars("12")); // "**"
console.log(hideMiddleChars("123")); // "***"
console.log(hideMiddleChars("1234567")); // "1****67"
~~~

### **Proxy拦截器**

描述

请补全JavaScript代码，请给参数对象添加拦截代理功能并返回这个代理。要求如下：

1. 该函数接收多个参数，首个参数为对象，从第二个参数（包括）往后皆是该对象的属性名
2. 通过该函数给首个参数对象添加拦截器功能，每当该对象访问到该函数第二个参数（包括）往后的属性时，返回"noright"字符串，表示无权限。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>

        <script type="text/javascript">
            const _proxy = (object,...prototypes) => {
                // 补全代码
                return new Proxy(object,{
                    get(target,prop){
                        if(prototypes.includes(prop)) return 'noright';
                        return object[prop];
                    }
                })
            }
        </script>
    </body>
</html>
~~~

### **监听对象**

请补全JavaScript代码，要求如下：

1. 监听对象属性的变化
2. 当"person"对象的属性发生变化时，页面中与该属性相关的数据同步更新

注意：

1. 必须使用Object.defineProperty实现且触发set方法时更新视图
2. 可以使用预设代码"_render"函数

解：

1. 创建”Observe“函数，接收一个对象参数，首先判断该对象参数是否合法，之后通过遍历对象的所有属性进行拦截操作。尽管可以直接使用Object.defineProperty函数对”person“对象进行拦截，但是可以通过创建”Observe“函数来封装对某个对象的属性劫持功能，之后可以复用此函数。
2. 创建“defineReactive”函数，接收三个参数分别为该对象、对象属性、对象属性值。该函数内部使用Object.defineProperty函数对该对象的属性值进行拦截，且每当触发set时，调用”render“方法重新渲染视图

~~~js
function Observe(target) {
    if (typeof target !== 'object' || target == null) {
        return target
    }
    for (var key in target) {
        defineReactive(target, key, target[key])
    }
}
function defineReactive(target, key, value) {
    Object.defineProperty(target, key, {
        get: function () {
            return value
        },
        set: function (newVal) {
            if (newVal !== value) {
                value = newVal
                _render(ul)
            }

        }

    })
}
Observe(person)

~~~

### promise的调用

请问以下JS代码输出的结果是（）

```
const p1 = Promise.resolve(117);
const p2 = Promise.resolve(p1);
const p3 = Promise.resolve(117);
console.log(p1 == p2,p1 === p2,p1 === p3);
```

1. **`const p1 = Promise.resolve(117);`**
   - 这行代码创建了一个 `p1` 的 Promise 对象，它会立即以值 `117` 进行解析。
   - `p1` 是一个 Promise 对象。
2. **`const p2 = Promise.resolve(p1);`**
   - 这行代码使用 `Promise.resolve(p1)` 创建了另一个 Promise 对象 `p2`。
   - 如果 `Promise.resolve` 接收到一个 Promise 对象，它会直接返回这个相同的 Promise 对象。因此，`p2` 和 `p1` 是相同的对象。
3. **`const p3 = Promise.resolve(117);`**
   - 这行代码创建了另一个 Promise 对象 `p3`，它也会被解析为值 `117`。
   - 尽管 `p1` 和 `p3` 都是解析为相同的值 `117`，但它们是不同的 Promise 对象。
4. **`console.log(p1 == p2, p1 === p2, p1 === p3);`**
   - `p1 == p2`: 检查 `p1` 和 `p2` 是否是相同的对象，由于 `p2` 就是 `p1`，因此结果为 `true`。
   - `p1 === p2`: 这同样检查 `p1` 和 `p2` 是否严格相等，结果仍为 `true`。
   - `p1 === p3`: 虽然 `p1` 和 `p3` 都是被解析为值 `117`，但它们是不同的 Promise 对象，因此结果为 `false`。

最终输出

因此，`console.log(p1 == p2, p1 === p2, p1 === p3);` 的输出将是：`true true false`。



### flex布局

需要实现一个左侧宽度固定，右侧元素自适应，应该在下面代码中补充哪个选项（）

<div class="container">

<div class="fixed-width">固定宽度</div>

<div class="flexible-width">自适应宽度</div>

~~~
</div>

.container {

display: flex;

}

.fixed-width {

width: 200px; /* 左边元素的固定宽度 */

}

.flexible-width {
  flex: 1;
   //或者flex-grow: 1; /* 右侧元素自适应宽度 */
}

~~~

### 实现二叉树找最大值

要在 JavaScript 中实现一个二叉树的最大值查找，你可以使用递归遍历的方式来查找二叉树中的最大值。以下是一个示例实现：

1. 定义二叉树节点结构：

首先，我们定义一个二叉树的节点结构，每个节点包含一个值以及指向其左、右子节点的引用。

```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}
```

2. 构建查找最大值的函数：

接下来，我们实现一个函数 `findMaxValue`，这个函数通过递归遍历二叉树来查找最大值。

```javascript
function findMaxValue(root) {
    // 如果当前节点为空，返回负无穷大，表示在这一支没有找到有效节点
    if (root === null) {
        return -Infinity;
    }

    // 递归查找左子树和右子树的最大值
    const leftMax = findMaxValue(root.left);
    const rightMax = findMaxValue(root.right);

    // 返回当前节点值、左子树最大值、右子树最大值中的最大值
    return Math.max(root.value, leftMax, rightMax);
}
```

3. 示例使用：

我们可以通过构建一个简单的二叉树并调用 `findMaxValue` 函数来查找该树中的最大值。

```javascript
// 构建一个简单的二叉树
let root = new TreeNode(3);
root.left = new TreeNode(1);
root.right = new TreeNode(5);
root.left.left = new TreeNode(0);
root.left.right = new TreeNode(2);
root.right.left = new TreeNode(4);
root.right.right = new TreeNode(6);

// 查找二叉树中的最大值
let maxValue = findMaxValue(root);
console.log("The maximum value in the binary tree is:", maxValue);
```

4. 输出结果：

在这个例子中，二叉树结构如下：

```
      3
     / \
    1   5
   / \ / \
  0  2 4  6
```

运行这段代码后，输出结果将是：

```
The maximum value in the binary tree is: 6
```

解释：

- 递归遍历二叉树，分别计算左右子树的最大值，并比较当前节点值与左右子树的最大值。
- 最终得到的结果是整个二叉树中的最大值。

### js 寻找字符串中出现最多的字符怎么实现

~~~
function findMostFrequentChar(str) {
    // 创建一个对象来保存每个字符的出现次数
    let charCount = {};

    // 遍历字符串，统计每个字符的出现次数
    for (let char of str) {
        if (charCount[char]) {
            charCount[char]++;
        } else {
            charCount[char] = 1;
        }
    }

    // 初始化最大次数和对应的字符
    let maxCount = 0;
    let maxChar = '';

    // 遍历统计结果，找到出现次数最多的字符
    for (let char in charCount) {
        if (charCount[char] > maxCount) {
            maxCount = charCount[char];
            maxChar = char;
        }
    }

    // 返回出现次数最多的字符
    return { character: maxChar, count: maxCount };
}

// 测试
let str = "javascript";
let result = findMostFrequentChar(str);
console.log(`The most frequent character is '${result.character}' with ${result.count} occurrences.`);

~~~

 ![image-20240815123422432](http://battle.wicp.io:9001/blog1/202408202215409.png)



### **合并k个已排序的链表**

合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。

数据范围：节点总数 0≤n≤50000≤*n*≤5000，每个节点的val满足 ∣val∣<=1000∣*v**a**l*∣<=1000

要求：时间复杂度 O(nlogn)

示例2

输入：

```
[{1,2},{1,4,5},{6}]
```

复制

返回值：

```
{1,1,2,4,5,6}
```

~~~js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here

    if(lists.length <=1) return lists[0] || null ;
    return merge(lists,0,lists.length);
}

function merge(lists,l,r){
    if(l>r)  return null ;
    if(l==r) return lists[l];
    const mid =Math.floor((l+r)/2);
    return mergeTwolist(merge(lists,l,mid),merge(lists,mid+1,r));//返回 的是一个排好序的list
}

function mergeTwolist(list1,list2){
    if(!list1||!list2) return list1||list2;
    let p1= list1,p2= list2,head = {next:null},p= head;
    while(p1&&p2){
        if(p1.val>p2.val){
            p.next= p2;
            p2=p2.next;
        }else{
            p.next = p1;
            p1=p1.next;

        }
        p=p.next;
    }
    p.next=p1||p2;
    return head.next;

}
module.exports = {
    mergeKLists : mergeKLists
};
~~~

### **判断链表中是否有环**

输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。

例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：

![img](http://battle.wicp.io:9001/blog1/202408202215410.png)

可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。

###### 示例1

输入：

```
{3,2,0,-4},1
```

返回值：

```
true
```

说明：

```
第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4->2存在一个链接，组成传入的head为一个带环的链表，返回true      
```

~~~js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here

    while(head){
        if(head.flag) return true;
        head.flag =true;
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
~~~

### 二分查找

请实现无重复数字的升序数组的二分查找

给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1

输入：

```
[-1,0,3,4,6,10,13,14],13
```

返回值：

```
6
```

说明：

```
13 出现在nums中并且下标为 6     
```

~~~
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
 */
function search( nums ,  target ) {
    // write code here
    let len = nums.length ;
    if(!len) return -1;
    let [left,right] = [0,len-1];
    while(left<=right){
        let mid = left +Math.floor((right-left)/2);
        let num =nums[mid];
        if(num === target) return mid;
        else if (num >target) right = mid-1;
        else left = mid +1;


    }
    return -1;

}
module.exports = {
    search : search
};
~~~



### 判断 对称二叉树

 对称二叉树，是一种二叉树，具有对称的性质，如： 

​      1  

​     /  \  

​    2   2  

​    / \   / \  

   3  4 4  3  

   现在给定一个二叉树的根节点，节点存储的值为整型数，请实现一个算法判断该二叉树是否为对称二叉树

~~~
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function isMirrorTree(root) {
    if (!root) return true; // 如果树为空，直接返回true
    return checkMirror(root.left, root.right);
}

function checkMirror(left, right) {
    // 如果两个节点相同（都是null），返回true
    if (left === right) return true;

    // 如果其中一个节点是null，或者两个节点值不同，返回false
    if (left === null || right === null || left.val !== right.val) return false;

    // 递归检查左子树和右子树是否对称
    return checkMirror(left.left, right.right) && checkMirror(left.right, right.left);
}

// 示例：
// 构造一个简单的镜像二叉树
let root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(2);
root.left.left = new TreeNode(3);
root.left.right = new TreeNode(4);
root.right.left = new TreeNode(4);
root.right.right = new TreeNode(3);

console.log(isMirrorTree(root)); // 输出 true

~~~

## **链表中环的入口结点**

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。
输入描述：输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这2个会组装成一个有环或者无环单链表
返回值描述：返回链表的环的入口结点即可。而我们后台程序会打印这个节点
示例1
输入：{1,2},{3,4,5}
返回值：3
说明：返回环形链表入口节点，我们后台会打印该环形链表入口节点，即3

通过定义slow和fast指针，slow每走一步，fast走两步，若是有环，则一定会在环的某个结点处相遇（slow == fast），根据下图分析计算，可知从相遇处到入口结点的距离与头结点与入口结点的距离相同。
![图片说明](http://battle.wicp.io:9001/blog1/202408202215411.png)

~~~js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
//定义快慢指针,感觉像是数学题
let fast = pHead;
let slow = pHead;

while(slow!=null && fast != null &&fast.next != null ){
    fast = fast.next.next;
    slow= slow.next;
    if(fast == slow){
        let p =pHead;
        while(p!=slow){
            p= p.next;
            slow = slow.next;
        }
        return p;
    }
}
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};

~~~

## 寻找峰值

~~~
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param nums int整型一维数组
 * @return int整型
 */
function findPeakElement(nums) {
    // write code here
    let peakIndx = -1;
    let len = nums.length
    peakIndx = binarySearch(0, len - 1);
    function binarySearch(left, right) {
        const mid = Math.floor((left + right) / 2);
        if (left === right) {
            return mid;
        }
        //判断mid右边是不是向上区间
        if (nums[mid + 1] > nums[mid]) {
            //右边是右向上区间，
            // mid不可能是峰值 所以+1，继续+1收缩找到上区间的分界线和下区间
            left = mid + 1;
        } else {
            // 如果右边是向下区间就往左收缩
            //不-1是因为mid可能是峰值，
            //             收缩之后如果left === right就是mid就是峰值
            right = mid;
        }
        return binarySearch(left, right);
    }
    return peakIndx;
}
module.exports = {
    findPeakElement: findPeakElement,
};

~~~

## 前序遍历

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return int整型一维数组
 */
function preorderTraversal( root ) {
    // write code here
     const res = [];
    preorder(root,res)
    return res;
}
function preorder(root,res) {
    if(root == null) {
       return;
    }
    // 前序遍历的位置
    res.push(root.val)
    preorder(root.left,res)
    preorder(root.right,res)
}

module.exports = {
    preorderTraversal : preorderTraversal
};
~~~

## **二叉树的最大深度**

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return int整型
 */
function maxDepth( root ) {
    // write code here
    return preorder(root);
}

function preorder(root){
    //前序遍历中判断最大深度
    //叶子节点null+1
    if(root==null) return 0;
    return Math.max(preorder(root.left),preorder(root.right))+1;
}
module.exports = {
    maxDepth : maxDepth
};
~~~

## **二叉搜索树与双向链表**

~~~
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function Convert(pRootOfTree)
{
    // write code here

     let head = null;
    let pre = null;
    function MediumOrderDFS (cur) {
        if(cur === null) {
            return;
        }
        // 递归左结点
        MediumOrderDFS(cur.left);
        // 处理当前结点
        if(pre === null) {
            head = cur;
        } else {
            pre.right = cur;
        }
        cur.left = pre;
        pre = cur;
        // 遍历右结点//
        MediumOrderDFS(cur.right);
    }
    MediumOrderDFS(pRootOfTree);
    return head;
}
module.exports = {
    Convert : Convert
};
~~~

## 按位置 **合并二叉树**

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param t1 TreeNode类 
 * @param t2 TreeNode类 
 * @return TreeNode类
 */
function mergeTrees( t1 ,  t2 ) {
    // write code here
    if(t1&&t2){
        t1.val+=t2.val;
        t1.left = mergeTrees(t1.left,t2.left);
        t1.right = mergeTrees(t1.right,t2.right);
    }
    return t1||t2;
}


module.exports = {
    mergeTrees : mergeTrees
};
~~~

## **链表中倒数最后k个结点**

~~~
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( pHead ,  k ) {
    // write code here
    //我称之为追赶法
    let [s,f]=[pHead,pHead];
    while(f!=null && k>0){
        f= f.next;
        k--;
    }

    if(k>0) return null;
    while(f!=null){
        s=s.next;
        f=f.next;
    }
    return s;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
~~~





## **两个链表的第一个公共结点**

~~~
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    let s= new Set();

    while(pHead1!==null){
        s.add(pHead1);
        pHead1=pHead1.next;
    }

    while(pHead2!=null){
        if(s.has(pHead2)){
            return pHead2;
        }
        pHead2=pHead2.next;
    }

    return null;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
~~~





## 链表尾对齐相加

~~~
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param head1 ListNode类
 * @param head2 ListNode类
 * @return ListNode类
 */

function ReverseList(phead) {
    if (!phead || !phead.next) {
        return phead;
    }
    let len = 0;
    let pre = null;
    let cur = null;

    while (phead) {
        cur = phead.next;
        phead.next = pre;
        pre = phead;
        phead = cur;
        len++;
    }
    return [pre, len];
}
function addInList(head1, head2) {
    // write code here

    //判空操作

    if (head1 == null) {
        return head2;
    }
    if (head2 == null) {
        return head1;
    }
    let [h1, len1] = ReverseList(head1);
    let [h2, len2] = ReverseList(head2);
    if (len2 > len1) {
        [h1, h2] = [h2, h1];
    }

    let carry = 0,
        num = 0; //进位标识符
    let resHead = h1;

    while (h2) {
        num = h1.val + h2.val + carry;
        h1.val = num % 10;
        carry = Math.floor(num / 10);
        h2 = h2.next;
        if (h2) {
            h1 = h1.next;
        }
    }

    while (carry) {
        if (h1.next) {
            h1 = h1.next;
            num = h1.val + carry;
            h1.val = num % 10;
            carry = Math.floor(num / 10);
        } else {
            h1.next = new ListNode(1);
            carry = 0;
        }
    }
    let [res, n] = ReverseList(resHead);
    return res;
}
module.exports = {
    addInList: addInList,
};

~~~

## 数组逆序对

~~~
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @return int整型
 */
function InversePairs( nums ) {
    // 归并

    let sum =0;
    mergeSort(nums);

    return sum %1000000007;
    function mergeSort(nums){

         if(nums.length < 2) return nums;
        let mid = Math.floor(nums.length/2);

        let left = nums.slice(0,mid);
        let right = nums.slice(mid);
        return merge(mergeSort(left),mergeSort(right));
    }

    function merge(left,right){
        let res = [];
        let leftlen = left.length;
        let rightlen= right.length;
        let len  = leftlen + rightlen;

        for(  let index =0,i=0,j=0;index<len;index++){

            //相当于两个升序数组在合并
            if(i>=leftlen) res[index] = right[j++];
            else if(j>= rightlen) res[index] = left[i++];
            else if(left[i]<=right[j]) res[index] = left[i++];
            else{
                res[index] = right[j++];
                sum+= leftlen-i;
                sum = sum % 1000000007;
            }
        }

        return res;
    }


}
module.exports = {
    InversePairs : InversePairs
};
~~~

## **根据包名，在指定空间中创建对象**

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        function namespace(oNamespace, sPackage) {
            //判断是不是对象
            if(Object.prototype.toString.call(oNamespace) != '[object Object]')return ;

            let tmpWrap = oNamespace;
            sPackage.split('.').forEach(i=>{
                //有则拷贝进去，无改字段，则拷贝为空对象
                tmpWrap = tmpWrap[i] = Object.assign({},tmpWrap[i]);
            });
            return oNamespace;
  
}

    </script>
</body>

</html>
~~~

## [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

~~~js

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
   if (nums.length === 0) {
      return 0; // 如果数组为空，直接返回 0
    }

    let dp = new Array(nums.length).fill(0); // 初始化 dp 数组，每个元素为 0
    dp[0] = 1; // 第一个元素的最长递增子序列长度为 1
    let maxans = 1; // 初始化最长递增子序列长度为 1

    // 从第二个元素开始遍历数组
    for (let i = 1; i < nums.length; i++) {
      dp[i] = 1; // 初始时 dp[i] 为 1，因为最小递增子序列长度至少为 1
      for (let j = 0; j < i; j++) {
        if (nums[i] > nums[j]) { // 如果 nums[i] 大于 nums[j]
          dp[i] = Math.max(dp[i], dp[j] + 1); // 更新 dp[i] 为 dp[j] + 1 和 dp[i] 中的较大值
        }
      }
      maxans = Math.max(maxans, dp[i]); // 更新最大递增子序列长度
    }

    return maxans; // 返回最终的最长递增子序列长度
    
};
~~~

## **高频数据类型**

~~~
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
const _findMostType = array => {
    let tem = {}
    let arr = []
    let maxnum = 0
    for(key of array) {
        let type = typeof key
        if(tem[type]) {
            tem[type] ++
        } else {
            tem[type] = 1
        }
        maxnum = tem[type] > maxnum ? tem[type] : maxnum
    }
    for(key in tem) {
        arr = tem[key] === maxnum ? [...arr,key] : arr
    }
    return [...arr,maxnum]
}

        </script>
    </body>
</html>
~~~

## **虚拟DOM**

~~~
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>

        <script>
            var vnode = {
                tag: 'ul',
                props: {
                    class: 'list'
                },
                text: '',
                children: [
                    {
                        tag: "li",
                        props: {
                            class: "item"
                        },
                        text: '',
                        children: [
                            {
                                tag: undefined,
                                props: {},
                                text: '牛客网',
                                children: []
                            }
                        ]
                    },
                    {
                        tag: "li",
                        props: {},
                        text: '',
                        children: [
                            {
                                tag: undefined,
                                props: {},
                                text: 'nowcoder',
                                children: []
                            }
                        ]
                    }
                ]
            }
            const _createElm = vnode => {
                // 补全代码
                let {tag,props,children,text} = vnode;
                if(typeof tag =="string"){
                    vnode.el = document.createElement(tag);
                    _setAttr(vnode.el,props);
                    vnode.el.appendChild(document.createTextNode(text));
                    children.forEach(child=>{
                        vnode.el.appendChild(_createElm(child));
                    })
                }else{
                    vnode.el = document.createTextNode(text);
                }
                return vnode.el;
            
            }

            const _setAttr = (elem,attrs)=>{
                for(key in attrs){
                    elem.setAttribute(key,attrs[key]);
                }
            }
        </script>
    </body>
</html>
~~~

## 查询重复元素

~~~
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */

    </style>
</head>

<body>
    <!-- 填写标签 -->
             <!-- let result=[]
            arr.forEach(function(elem){
                if(arr.indexOf(elem) != arr.lastIndexOf(elem) && result.indexOf(elem) == -1){
                    result.push(elem);
                }
             });
            return result; -->
    <script type="text/javascript">
        // 填写JavaScript
        function duplicates(arr) {
          return arr.filter((el, i)=>arr.lastIndexOf(el) != i  &&  i == arr.indexOf(el))

}
    </script>
</body>

</html>
~~~

## 计数器

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
        function count(start, end) {
            console.log(start);
            var timer = setInterval(()=>{
                if(start<end){
                    console.log(++start);
                }else{
                    clearInterval(timer);
                }
            },100);
            return {
                cancel(){
                    clearInterval(timer);
                }
            }
}
    </script>
</body>

</html>
~~~

## **JS63** **模块**

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
        function createModule(str1, str2) {
            let obj={
                greeting: str1,
                name: str2,
                sayIt(){
                        return this.greeting+', '+this.name
                    }
            }
         //   obj.sayIt = function() {
          //        return this.greeting + ', ' + this.name;
           //     }
            return obj;
}
    </script>
</body>

</html>
~~~

## [组合](https://leetcode.cn/problems/combinations/)

~~~js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */

     let result =[];
    let path= [];
var combine = function(n, k) {

//回溯
result=[];
combineHelper(n,k,1);
return result;

};

const combineHelper = (n, k, startIndex) =>{
    if(path.length==k){
        result.push([...path]);
        return 
    }
    for(let i=startIndex;i<=n-(k-path.length)+1;i++){
        path.push(i);
        combineHelper(n,k,i+1);
        path.pop();
    }
}
~~~

## 赎金信

~~~js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    let map = new Map();
    magazine.split('').forEach((item)=>{
        map.has(item)? map.set(item,map.get(item)+1):map.set(item,1);
    });
    for(let w of ransomNote){
        if(!map.has(w)||map.get(w)<=0)return false;
        map.set(w,map.get(w)-1);
    }
    return true;
};
~~~

## 实例本身属性遍历

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
        function iterate(obj) {
            //1.Object.keys
           // const keyArr =Object.keys(obj);
           // const temp = [];
          //  for(let i in keyArr){
         //       temp[i] = keyArr[i].concat(': ',obj[keyArr[i]]);
         //   }
           /// return temp;
            ///2. for in  and hasOwnProperty
            const temp =[];
        for (let key in obj){
              if(obj.hasOwnProperty(key)){
                 temp.push(key.concat(': ',obj[key]));
             }
           }
         return temp;
}
    </script>
</body>

</html>
~~~

## **判断是否符合指定格式**

给定字符串 str，检查其是否符合如下格式
1、XXX-XXX-XXXX
2、其中 X 为 Number 类型

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
       /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
        function matchesPattern(str) {
            //首先两减号连接
            const strarray = str.split("-"). map(( item) => + item);
            if(strarray.length!==3) return false;
            return strarray.every((item)=>{
                return (
            ! isNaN( item) &&
            typeof item === "number" &&
            strarray[0]. toString(). length === 3 &&
            strarray[1]. toString(). length === 3 &&
            strarray[2]. toString(). length === 4
          );
            })

}
    </script>
</body>

</html>
~~~

## [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

~~~js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
        let map = new Map(),arr=[...new Set(nums)];
        nums.map((num)=>{
            if(map.has(num))map.set(num,map.get(num)+1)
            else map.set(num,1)
        })

        return arr.sort((a,b)=>map.get(b)-map.get(a)).slice(0,k);
};

~~~

## [组合总和](https://leetcode.cn/problems/combination-sum/)

注意是无限制的重复选择数字

~~~js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    //
    let res = [];

    const dfs=(start, temp, sum) => { // start是当前选择的起点索引 temp是当前的集合 sum是当前求和
        if(sum>=target){
            if(sum==target)res.push(temp.slice());//temp浅拷贝
            return;
        }
        for(let i = start;i<candidates.length;i++){
            temp.push(candidates[i]);
            dfs(i,temp,sum+candidates[i]);//有重复的挑选可重复选择i
            temp.pop();
        }

    }
    dfs(0,[],0);
    return res;
};
~~~

///

## [子集](https://leetcode.cn/problems/subsets/)

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    let res = [];

    const dfs = (path, start) => {
        //if(start>nums.length) return ;
        res.push(path.slice());

        for (let i = start; i < nums.length; i++) {
            path.push(nums[i]);
            dfs(path, i + 1);
            path.pop();
        }

    }
    dfs([], 0);
    return res;

};
~~~

## [非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function(nums) {
    const res=[];
    dfs(res,nums,0,[]);//结果，输入，开始下标，暂存路径
    return res;
};

const dfs=(res,nums,startIndex,path)=>{
    if(path.length>=2) res.push([...path]);//大于二的非递减压入数组

    const set = new Set();

//当前进入的节点的后续操作，选择后续的哪些节点是否进入
for(let i=startIndex;i<nums.length;i++){
    //剪枝，当不是 >= path的末尾，说明是递减，不走。
    if(nums.length>0&&path[path.length-1]>nums[i]) continue;
    //当前层选择下一层，也许有许多重复元素，去重，不选择
    if(set.has(nums[i]+100))  continue;

    set.add(nums[i]+100);
    path.push(nums[i])
    dfs(res,nums,i+1,path);
    path.pop();
}
}
~~~

## [全排列](https://leetcode.cn/problems/permutations/)

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {

    const res = [];
    const used = {};

    const dfs =(path)=>{
        if( path.length===nums.length){ res.push(path.slice());return ;}
         for (const num of nums) { // for枚举出每个可选的选项
            // if (path.includes(num)) continue; // 别这么写！查找是O(n)，增加时间复杂度
            if (used[num]) continue; // 使用过的，跳过
            path.push(num);         // 选择当前的数，加入path
            used[num] = true;       // 记录一下 使用了
            dfs(path);              // 基于选了当前的数，递归
            path.pop();             // 上一句的递归结束，回溯，将最后选的数pop出来
            used[num] = false;      // 撤销这个记录
        }
    }

    dfs([]);
    return res;
};
~~~

## 全排列2

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

 ~~~js
 /**
  * @param {number[]} nums
  * @return {number[][]}
  */
 var permuteUnique = function(nums) {
     const res = [];
     const used = new Array(nums.length);
     nums.sort((a, b) => a - b); // 升序排序
 
     const dfs =(path)=>{
         if( path.length===nums.length){ res.push(path.slice());return ;}
          for (let i = 0; i < nums.length; i++) { // for枚举出每个可选的选项
             // if (path.includes(num)) continue; // 别这么写！查找是O(n)，增加时间复杂度
              if (used[i]) {                      // 这个数使用过了，跳过。
                 continue;
             }
              if (i - 1 >= 0 && nums[i - 1] == nums[i] && !used[i - 1]) { // 避免产生重复的排列
                 continue;
             }
  path.push(nums[i]); // make a choice
             used[i] = true;     // 记录路径上做过的选择
             dfs(path);       // explore，基于它继续选，递归
             path.pop();         // undo the choice
             used[i] = false;    // 也要撤销一下对它的记录
         }
     }
 
     dfs([]);
     return res;
 };
 ~~~

## [子集 II](https://leetcode.cn/problems/subsets-ii/)

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function (nums) {
    nums.sort((a,b)=>a-b);
    const res = [];
    const dfs = (path, start) => {
        //if(start>nums.length) return ;
        
        res.push(path.slice());

        for (let i = start; i < nums.length; i++) {
            if(i>start && nums[i] === nums[i - 1]) continue;
            path.push(nums[i]);
            dfs(path, i + 1);
            path.pop();
        }

    }
    dfs([], 0);
    return res;


};
~~~
## [跳跃游戏](https://leetcode.cn/problems/jump-game/)

~~~js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
        let cover =0;
        if(nums.length ==1)return true;

        for(let i=0;i<=cover;i++){
            cover = Math.max(nums[i]+i,cover);//每次前进，都将最远的步数赋值给cover
            if(cover>=nums.length-1)return true;
        }
        return false;
};
~~~

## 加油站

~~~JS
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
      let sum =0;
      let min =0;
      for( let i=0;i<gas.length;i++){
        sum+=(gas[i]-cost[i]);
        min= Math.min(sum,min);
      }
      if(sum<0) return -1;//总的油不够路程，必然不够
      if(min>=0)  return 0;//最小的差值都是》=0，说明从0开始出发一直都是有油 的状态4
        //逆序补充，上面一步已经取到了最小的负数min，逆序进行填平这个负数，当填为正数说明就是从当前的 下标开始就是可以的

        for(let i=gas.length-1;i>0;i--){
            min+=(gas[i]-cost[i]);//i行驶后剩余的油
            if(min>=0) return i;
        }
        return -1;

};
~~~

## 组合总和3

~~~js
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {

    const res =[]
    const path=[];

    const dfs =(path,step)=>{
        if(path.length>k)return ;
        const pathsum= path.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
        if(path.length==k&&pathsum==n){
            res.push(path.slice());
            return ;
        }
        for(let i=step;i<=9;i++){//不重复只能是1--9
            path.push(i);
            dfs(path,i+1);
            path.pop();
        }
    }

    dfs(path,1);
    return res;
};
~~~

## [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

涉及去重

~~~js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
// var combinationSum2 = function(candidates, target) {
//         let res =new Set();
//         let path=[]

//         const dfs=(path,step)=>{
            
//             const pathsum = path.reduce((a,b)=>a+b,0);
//             if(pathsum>target)return;
//             if(pathsum==target) {
//             res.push(path.slice());
//             return;
//         }
//             for(let i=step;i<candidates.length;i++){

//                 if (i > step && candidates[i] === candidates[i - 1]) continue;
//                 path.push(candidates[i]);
//                 dfs(path,i+1);
//                 path.pop();
//             }

//         }
//         dfs(path,0)
//         return res
// };

var combinationSum2 = function(candidates, target) {
    let res = new Set();
    let path = [];

    // Sort to help skip duplicates
    candidates.sort((a, b) => a - b);

    const dfs = (path, step) => {
        const pathSum = path.reduce((a, b) => a + b, 0);
        if (pathSum > target) return;
        if (pathSum === target) {
            res.add(JSON.stringify(path.slice())); // Add the stringified array to the set
            return;
        }

        for (let i = step; i < candidates.length; i++) {
            if (i > step && candidates[i] === candidates[i - 1]) continue; // Skip duplicates
            path.push(candidates[i]);
            dfs(path, i + 1);
            path.pop();
        }
    };

    dfs(path, 0);
    
    // Convert the set back to an array of arrays
    return Array.from(res).map(item => JSON.parse(item));
};

~~~



## [根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

~~~js

/**
 * @param {number[][]} people
 * @return {number[][]}
 */
// var reconstructQueue = function (people) {
//     //首先降序排序，因为前面的身高必然均高于后面的，所以放心的用第二个数字作为下标插入就是

//     const peopleDesc = people.toSorted((a, b) => {
//         if (b[0] === a[0]) return a[1] - b[1]; // 身高相同时，按照第二个值升序排列
//         return b[0] - a[0]; // 否则按照身高降序排列
//     });
//     // 用一个空数组 result 来存储结果
//     // 用一个空数组 result 来存储结果
//     const result = [];

//     // 按照第二个数字 k 插入到相应的位置
//     for (let p of peopleDesc) {
//         result.splice(p[1], 0, p); // 在 k 位置插入元素 p
//     }

//     return result; // 返回重新排序的队列
// };
var reconstructQueue = function(people) {
    // 首先按照身高降序排列，如果身高相同，则按照第二个值升序排列
    const peopleDesc = people.toSorted((a, b) => {
        if (b[0] === a[0]) return a[1] - b[1]; // 身高相同时，按照第二个值升序排列
        return b[0] - a[0]; // 否则按照身高降序排列
    });

    // 遍历数组，通过 splice 移动元素
    for (let i = 0; i < peopleDesc.length; i++) {
        const p = peopleDesc[i]; // 当前要处理的元素
        const targetIndex = p[1]; // 元素应插入的目标位置
        
        // 如果当前元素的位置不等于它的目标位置，才需要移动
        if (i !== targetIndex) {
            // 移除当前元素
            peopleDesc.splice(i, 1);
            // 在目标位置插入元素
            peopleDesc.splice(targetIndex, 0, p);
        }
    }

    return peopleDesc; // 返回重构后的数组
};

~~~

~~~
const obj={
    name:'shade',
    sayHai:()=>{console.log(this.name)}
}

obj.sayhai();
~~~

## [用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

~~~js
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    const parray = points.toSorted((a,b)=>a[0]-b[0])
    //首先更新，至少需要一支箭
    let count =1;
    for(let i = 1;i<parray.length;i++){
        //如果不在一个重叠区，那么就加一只箭，作为下一个区间的jian
        if(parray[i][0]>parray[i-1][1]){
            //说明当前的最左，和前一个的最右已经无法联系上，也就是有断层
            count++; //增加一支箭为当前的区间使用
        }else{
            //更新最小的右侧，有可能当前的右侧比最开始的右侧还要小
            parray[i][1]= Math.min(parray[i][1],parray[i-1][1]);
        }
    }
    return count;
};
~~~

## [无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

~~~js
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    //首先进行升序
    const Inter = intervals.toSorted((a,b)=>a[0]-b[0])
    //初始化区间右边界
    let pre =Inter[0][1];
    let remove=0;
    for(let i=1;i<intervals.length;i++){
        if(pre>Inter[i][0]){
            remove++;
            pre= Math.min(pre,Inter[i][1])
        }else{
            pre=Inter[i][1]
        }
    }
    return remove;
};
~~~

## [划分字母区间](https://leetcode.cn/problems/partition-labels/)

本质也是求不重叠区间

~~~js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function(s) {
        //标记每个字母的两端，这样一来就可以看成是重叠区间 了
        //字母字典 距离值
        let maxposi={};
        for (let i=0;i<s.length;i++){
                        maxposi[s[i]]=i
        }

        const  res =[];
        let start =0;
        let dangqianMaxposi=0;

        for(let i=0;i<s.length;i++){
            const cur = maxposi[s[i]];
            dangqianMaxposi= Math.max(dangqianMaxposi,cur);
            if(i==dangqianMaxposi){
                //开始分片
                res.push(i-start+1);
                start=i+1;
            }
        }

        return res;

};
~~~

## [合并区间](https://leetcode.cn/problems/merge-intervals/)

~~~js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    // 先对区间按照起点进行排序
    intervals.sort((a, b) => a[0] - b[0]);

    const res = [];
    let maxright = intervals[0][1];
    let start = intervals[0][0];

    for (let i = 1; i < intervals.length; i++) {
        // 如果当前区间的起点大于上一个区间的最大右边界，说明不重叠
        if (intervals[i][0] > maxright) {
            res.push([start, maxright]); // 将之前的区间加入结果集
            start = intervals[i][0];     // 更新起点为当前区间的起点
            maxright = intervals[i][1];  // 更新最大右边界为当前区间的终点
        } else {
            // 区间重叠，更新最大右边界
            maxright = Math.max(intervals[i][1], maxright);
        }
    }

    // 最后一个区间加入结果集
    res.push([start, maxright]);
    return res;
};

~~~

## [不同路径](https://leetcode.cn/problems/unique-paths/)

~~~js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
     let dp = Array.from({
    length: m
  }, x => Array.from({
    length: n
  }))

    for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i === 0 && j === 0 || i === 0 && j !== 0 || i !== 0 && j === 0) {
        dp[i][j] = 1
      } else if (i !== 0 && j !== 0) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
      }
    }
  }
  return dp[m - 1][n - 1]

};
~~~

## [不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

~~~js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function (obstacleGrid) {
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;
    let graph = Array.from({ length: m + 1 }, x => Array.from({ length: n + 1 }, () => 0));
    // graph = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

    if (obstacleGrid[0][0] === 1) return 0; // 如果起点有障碍物，直接返回 0
    graph[1][1] = 1; // 设置起点初始路径数量
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (obstacleGrid[i - 1][j - 1] === 1)
                graph[i][j] = 0;
            else if (i > 1 || j > 1) {
                // 非起点位置的路径数量等于上方和左方路径数量之和
                graph[i][j] = graph[i - 1][j] + graph[i][j - 1];
            }
        }
    }
    return graph[m][n]
};
~~~

## [整数拆分](https://leetcode.cn/problems/integer-break/)

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
        let dp = Array.from({length:n + 1 },()=>0);
        dp[2]=1;
        for(let i=3;i<=n;i++)
            for(let j=1;j<=i-j;j++){
                dp[i]= Math.max(dp[i],Math.max(j*dp[i-j],j*(i-j)))
            }
        return dp[n]

    
};
~~~



## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

~~~js
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */


var change = function (amount, coins) {
    // const dp    = new Array(amount + 1).fill(0);
     const dp    =Array.from({length:amount + 1},()=>0);
    dp[0] = 1; // 没有硬币时有一种组合，即什么都不选
    const valid =new  Array(amount+1).fill(false);

    dp[0]=1; //没有硬币时有一种组合
    valid[0]=true;
    for(const coin of coins){
        for(let i = coin;i<=amount;i++){
            valid[i]|=valid[i-coin];
        }
    }
    if(!valid[amount]) return 0;//先行判断是否可以满足这个组合
    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }

    return dp[amount];
}

//超时
// var change = function(amount, coins) {
//     // 回溯法
//     let res = [];

//     // 深度优先搜索（回溯）函数
//     var dfs = (i, path, cursum) => {
//         // 如果当前和超过目标值，直接返回
//         if (cursum > amount) return;

//         // 如果当前和等于目标值，保存结果
//         if (cursum === amount) {
//             res.push([...path]);
//             return;
//         }

//         // 遍历硬币数组
//         for (let k = i; k < coins.length; k++) {
//             path.push(coins[k]); // 选择当前硬币
//             dfs(k, path, cursum + coins[k]); // 递归调用，cursum 累加当前硬币
//             path.pop(); // 回溯，撤销选择
//         }
//     };

//     // 从第一个硬币开始搜索
//     dfs(0, [], 0);
//     return res.length;
// };


 //超时
// var change = function(amount, coins) {
    
//     //回溯法

//     let path=[];
//     let res=[];
//     let sum=0

//     var dfs = (i,path,cursum)=>{
//         if(cursum>amount) return ;
//         if(cursum==amount) {res.push([...path])
//                 return }
//         for(let k=i;k<coins.length;k++){
//             path.push(coins[k])
//             sum = path.reduce((a, b) => a + b, 0);
//             dfs(k,path,sum)
//             path.pop()
//             sum-=coins[k];
//         }

//     }
//     dfs(0,path,sum);
//     return res.length;
// };
~~~

## [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

~~~js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */


var maxSlidingWindow = function (nums, k) {
    // 自定义一个单调队列
    class MyQueue {
        constructor() {
            this.deque = []; // 使用数组来模拟双端队列
            // for (const val of arr) {
            //     this.add(val);
            // }
        }

        // 弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出
        // 同时判断队列当前是否为空
        poll(val) {
            if (this.deque.length > 0 && val === this.deque[0]) {
                this.deque.shift(); // 移除队列前端的元素
            }
        }

        // 添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出
        // 保证队列元素单调递减
        // 比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2
        add(val) {
            while (this.deque.length > 0 && val > this.deque[this.deque.length - 1]) {
                // 如上，我们移除了1
                this.deque.pop(); // 移除队列尾部的元素
            }
            this.deque.push(val); // 将新的值加入队列尾部
        }

        // 队列队顶元素始终为最大值
        peek() {
            // 返回队列的头部元素，但不移除
            return this.deque[0];
        }
    }

    if (nums.length == 1) return nums;

    let len = nums.length - k + 1;
    let res = [];
    //前k个元素先入队
    let Q = new MyQueue();

    // 先将前 k 个元素入队
    for (let i = 0; i < k; i++) {
        Q.add(nums[i]);
    }
    res[res.length++] = Q.peek();
    for (let i = k; i < nums.length; i++) {
        Q.poll(nums[i - k]);
        Q.add(nums[i]);
        res.push(Q.peek())
    }
    return res;



};
~~~



## 重新安排行程

~~~js
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
    // 将 tickets 转换为邻接表 map<origin, dest[]>
    let map = new Map();

    for (let [origin, dest] of tickets) {
        if (!map.has(origin)) {
            map.set(origin, []);
        }
        map.get(origin).push(dest);
    }

    // 将目的地排序，以便后续按字母序优先访问
    for (let dests of map.values()) {
        dests.sort();
    }

    let res = [];
    
    // 使用栈模拟递归的深度优先搜索
    let stack = ["JFK"];
    
    while (stack.length > 0) {
        let current = stack[stack.length - 1];
        if (map.has(current) && map.get(current).length > 0) {
            // 取出当前节点的下一个目的地，并将其压入栈中
            stack.push(map.get(current).shift());
        } else {
            // 当前节点没有目的地了，添加到结果中
            res.push(stack.pop());
        }
    }

    // 因为是逆向插入结果，因此需要翻转
    return res.reverse();
};

~~~

## [单词拆分](https://leetcode.cn/problems/word-break/)

~~~js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    let set = new Set(wordDict); // 使用 Set 存储 wordDict 中的单词，以便快速查找
    let valid = new Array(s.length + 1).fill(false); // DP 数组 valid[i] 表示 s 的前 i 个字符能否被 wordDict 拆分
    valid[0] = true; // 空字符串总是可以被拆分，因此设置 valid[0] = true

    // 从第 1 个字符开始，遍历整个字符串 s
    for (let i = 1; i <= s.length; i++) { // 改为 i <= s.length 确保遍历整个字符串
        // 遍历当前子串的所有可能的前缀，尝试找到是否有拆分点
        for (let j = 0; j < i; j++) {
            // 如果 s[j:i] 在字典中，并且 valid[j] 为 true，则表示前 i 个字符可以被拆分
            if (set.has(s.slice(j, i)) && valid[j]) {
                valid[i] = true;
                break; // 一旦找到一个可行拆分，就可以结束内层循环
            }
        }
    }

    return valid[s.length]; // 最终返回是否可以将整个字符串 s 拆分
};

~~~

## [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    // 修正拼写错误：cosnt -> const
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            //对于 i 个节点，我们选择一个节点 j 作为根节点。
//j-1 个节点在左子树上，i-j 个节点在右子树上。
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
};

~~~

