---
title: js刷题
date: 2024-07-10 14:42:15
permalink: /pages/9c117d/
categories:
  - 技术
  - 刷题
tags:
  - 
author: 
  name: henryboom
  link: https://github.com/henryboom
---
### **列表内容排序再渲染**

场景描述：在一个 HTML 页面中，有一个无序列表（ul），其中包含了一些项目（li）。每个项目都有一个文本内容和一个唯一的 ID。你需要编写一个 JavaScript 函数来提取列表中所有项目的文本内容，并将它们按照 ID 进行排序，然后将排序后的文本内容重新渲染回去。

代码实现：补全sortAndReturnTextContent函数，实现功能

运行sortAndReturnTextContent函数前

![img](http://battle.wicp.io:9001/blog1/202408202215406.png)

运行sortAndReturnTextContent函数后

![img](http://battle.wicp.io:9001/blog1/202408202215408.png)

~~~js
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">


</head>

<body>
  <ul id="myList">
    <li id="item1">项目 1</li>
    <li id="item3">项目 3</li>
    <li id="item2">项目 2</li>
    <li id="item4">项目 4</li>
  </ul>

  <script>
    function sortAndReturnTextContent() {
      const items = document.getElementById('myList').children;
      // 在此补全代码
      const newItems = Array.from(items).sort((a,b)=> parseInt(a.id.slice(4)) - parseInt(b.id.slice(4)));
      document.getElementById('myList').innerHTML = newItems.map(item => item.outerHTML).join('');
    }
    sortAndReturnTextContent()
  </script>
</body>

</html>
~~~

###  **文件扩展名**

要求以字符串的形式返回文件名扩展名，文件名参数为"filename"。

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        
        <script>
            const _getExFilename = (filename) => {
                // 补全代码
                //使用.分割，取最后一个元素，拼接.
                let filenameArray = filename.split('.');
                return '.'+filenameArray[filenameArray.length-1]
            }
        </script>
    </body>
</html>
~~~

### **分隔符**

##### 示例1

输入：

```
_comma(12300)
```

输出：

```
'12,300'
```

~~~js
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
        /* 填写样式 */
    </style>
</head>

<body>
    <!-- 填写标签 -->
    <script type="text/javascript">
        // 填写JavaScript
       

function _comma(number) {
                // 补全代码
                 if (number < 1000) {
                        return number.toString();
                    } else {
                        return _comma(Math.floor(number / 1000)) + "," + _comma(number % 1000);
                    }
            }
    </script>
</body>
</html>
~~~

### **单向绑定**

要求每当id为"input"的输入框值发生改变时触发id为"span"的标签内容同步改变。
注意：

1. 必须使用DOM0级标准事件（onchange）

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	<input id="input" type="text" onchange="change(value)"/>
        <span id="span"></span>

        <script type="text/javascript">
            // 补全代码
            //获取input的变化
            
            //监听输入的数值，进行赋值道span
            function change(value){
                const span = document.querySelector("#span")
                span.innerHTML = value
            }
                  //     document.getElementById("input").onchange = function(){
                // dom事件里的函数的this指向触发者，即input标签
                // 注意：这里不能使用箭头函数，因为箭头函数没有this指针，箭头函数的this是根据执行上下文确定的，即这里的this指向window，会报错
             //   document.getElementById("span").innerHTML = this.value
//}
        </script>
    </body>
</html>
~~~

### **创建数组**

要求返回一个长度为参数值并且每一项值都为参数值的数组。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _createArray = (number) => {
                // 补全代码
               // return Array(number).fill(number)//长度为number,元素为number
          const array = [...Array(number)].map((item)=>{
                              return number
                          })
                 
                return array
                         //  return Array.from({length:number},()=>number)//类数组转换
                //Array.from(arrayLike, mapFn, thisArg)
                //arrayLike类数组，mapFn：类似map的执行函数，迭代每个元素，thisArg：this上下文
            }
        </script>
    </body>
</html>
~~~

### 判断版本

该函数接收两个参数分别为旧版本、新版本，当新版本高于旧版本时表明需要更新，返回true，否则返回false。
注意：

1. 版本号格式均为"X.X.X"
2. X∈[0,9]
3. 当两个版本号相同时，不需要更新

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _shouldUpdate = (oldVersion, newVersion) => {
                // 补全代码
       // return Number(newVersion.replace(/\./g, '')) > Number(oldVersion.replace(/\./g, ''))
 // 先将新旧版本值 转为数组再将他们转为字符串
 //   let oldStr = oldVersion.split('.').join('') // '111' 老版本
   // let newStr = newVersion.split('.').join('') // '222' 新版本
    // 直接即可 关系操作符 如果两侧都是字符串 那么会逐个比较每一位的字符串编码
  //  return newStr > oldStr;
  return newVersion>oldVersion

            }
        </script>
    </body>
</html>
~~~

### **数组排序**

根据预设代码中的数组，实现以下功能：

1. 列表只展示数组中的name属性
2. 实现点击"销量升序"按钮，列表内容按照销量升序重新渲染
3. 实现点击"销量降序"按钮，列表内容按照销量降序重新渲染

注意：

1. 必须使用DOM0级标准事件（onclick）

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <button class='up'>销量升序</button>
        <button class='down'>销量降序</button>
        <ul></ul>

        <script>
            var cups = [
                { type: 1, price: 100, color: 'black', sales: 3000, name: '牛客logo马克杯' },
                { type: 2, price: 40, color: 'blue', sales: 1000, name: '无盖星空杯' },
                { type: 4, price: 60, color: 'green', sales: 200, name: '老式茶杯' },
                { type: 3, price: 50, color: 'green', sales: 600, name: '欧式印花杯' }
            ]
            var ul = document.querySelector('ul');
            var upbtn = document.querySelector('.up');
            var downbtn = document.querySelector('.down');
            // 补全代码
      upbtn.onclick=function() {
            cups.sort((a,b) => a.sales-b.sales)
            const str= cups.map((item,index)=>{
                return `
                    <li> ${item.name} </li>
                `
            })
            ul.innerHTML=str.join('')
        }
        downbtn.onclick =function(){
            const str = cups.map((item, index) => {
                return `
                    <li> ${item.name} </li>
                `
            })
             ul.innerHTML = str.join('')
            }
            
        </script>
    </body>
</html>
~~~

### 

### **参数解析器**

要求将字符串参数URL中的参数解析并以对象的形式返回。

##### 示例1

输入：

```
getParams('https://nowcoder.com/online?id=1&salas=1000')
```

输出：

```
{id:1, salas: 100}
```

~~~JS
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>

        <script>
            const _getParams = (url) => {
                // 补全代码
                //截取？之后的字符串
// 提取查询参数部分并将其拆分成数组
let obj = {};
  let splitUrl = url.slice(url.lastIndexOf('?') + 1).split('&'); 
 // 将每个查询参数中的 = 替换为 : 并添加引号
 splitUrl.map(element => {let [key, value] = element.split('=');
 obj[key] = value;} )
  // 将数组元素组合成一个对象形式的字符串
 //let str = `{${newArray.join(',')}}`; 
  // 使用 JSON.parse 将格式化后的 JSON 字符串解析为对象
  //let obj = JSON.parse(str);
  //return obj; // 返回解析后的对象
  //let arr = url.match(/(\w+)=(\w+)/gi);
return obj;
}
        </script>
    </body>
</html>
~~~

### 生成页码

要求根据参数动态生成"li"标签页码并插入"ul"标签下。要求如下：

1. "allItem"为总数据项个数，"pageItem"为每页的数据项个数
2. "li"标签内容为当前页码数，页码从1开始

##### 示例1

输入：

```
_createPage(13,2)
```

输出：

```
"li"长度为7，"li"内容依次为"1","2","3","4","5","6","7"
```

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	<ul id="ul">
            
        </ul>
        <script type="text/javascript">
            const _createPage = (allItem, pageItem) => {
                // 补全代码
                //这里涉及到最后一页没有存满的 情况
                //创建一个数组，长度为Math.ceil(allItem/pageItem)
                let arr = new Array(Math.ceil(allItem/pageItem)).fill(0).map((_, index) => index+1);
                //let arr = Array.from({length: Math.ceil(allItem/pageItem) }, (_, index) => index+1);

                let ul = document.querySelector('#ul')
                arr.map(e=> {
                    let li = document.createElement('li')
                    li.innerText = e
                    ul.appendChild(li)
                })
            }
        </script>
    </body>
</html>
~~~

### **总成绩排名**

要求将数组参数中的对象以总成绩(包括属性"chinese"、"math"、"english")从高到低进行排序并返回。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
        const _rank = array => {
            // 补全代码
            //不能修改原数组
           // array.map(e =>{  e.sum=e.chinese+e.math+e.english })
           //return  array.sort((a,b)=>{b.sum-a.sum})
              array.sort((left, right) => {
        let lg = left.chinese + left.math + left.english
        let rg = right.chinese + right.math + right.english
        return rg - lg
    })
    return array
        }
        </script>
    </body>
</html>
~~~

### **子字符串频次**

该函数接受两个参数分别为字符串、子字符串，要求返回子字符串在字符串中出现的频次。

~~~js
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>

        <script>
            const _searchStrIndexOf = (str, target) => {
                // 补全代码
                //有可能存在ssss ss，判断不出3的情况，子串也许重叠
            //    return str.split(target).length - 1
          //        let reg=new RegExp(target,'g');
   // return str.match(reg).length;
            let index = str.indexOf(target)
            let sum = 0
            while (index > -1) {
               // indexOf表示元素第一次出现的下标
                index = str.indexOf(target, index + 1)
                sum++
                }
            return sum
            }
        </script>
    </body>
</html>
~~~

### **判断斐波那契数组**

要求以Boolean的形式返回参数数组是否为斐波那契数列。在数学上，斐波那契数列以如下方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）
注意：

1. [0,1,1]为最短有效斐波那契数列

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>
    	
        <script type="text/javascript">
            const _isFibonacci = array => {
                // 补全代码
                 if(array.length < 3 || array[0] !== 0 || array[1] !== 1) return false
                // for(let i=2 ; i<array.length ; i++) {
               //       if(array[i] === array[i-1] + array[i-2]) continue
               //       return false
              //    }
             //     return true
             //只要有一个不符合就会返回false
            return     array.every((item, index) =>
          index < 3
            ? array[0] === 0 && array[1] === 1 && array[2] === 1
            : item === array[index - 1] + array[index - 2]
        );

            }
        </script>
    </body>
</html>
~~~

### this指向的变更

~~~js
var num1 = 1, num2 = 2;

function cal() {
    var num1 = 10, num2 = 20;
    console.log(this.num1 + this.num2);
}

var calBind = cal.bind({num1: 100, num2: 200});

new cal(); // (1)
cal(); // (2)
new calBind(); // (3)
calBind(); // (4)

~~~

#### 分析每个函数调用的结果

1. **`new cal()`**

   - 当使用 `new` 关键字调用函数时，会创建一个新的对象，并将该对象设置为函数调用中的 `this` 值。
   - 因此，在 `new cal()` 调用中，`this` 指向一个新创建的对象，它没有 `num1` 和 `num2` 属性。
   - 代码中的局部变量 `num1` 和 `num2` 并不影响 `this.num1` 和 `this.num2`。
   - 所以 `this.num1` 和 `this.num2` 都是 `undefined`。
   - `undefined + undefined` 结果为 `NaN`。

   ```javascript
   new cal(); // 输出 NaN
   ```

2. **`cal()`**

   - 直接调用函数时，`this` 默认指向全局对象（在浏览器中为 `window`，在 Node.js 中为 `global`），因为我们不是严格模式。
   - 在全局对象中，`num1` 和 `num2` 分别为 `1` 和 `2`。
   - 因此，`this.num1` 是 `1`，`this.num2` 是 `2`。

   ```javascript
   cal(); // 输出 3
   ```

3. **`new calBind()`**

   - `calBind` 是通过 `Function.prototype.bind` 创建的新函数，`this` 永久绑定到 `{num1: 100, num2: 200}`。
   - 然而，使用 `new` 关键字调用 `calBind` 时，会创建一个新的对象，并将其设置为 `this`。
   - 根据 `bind` 的行为，在使用 `new` 时，绑定的 `this` 会被忽略。
   - 由于 `cal` 函数中的局部变量 `num1` 和 `num2` 不影响新创建对象的 `this.num1` 和 `this.num2`，它们都是 `undefined`。

   ```javascript
   new calBind(); // 输出 NaN
   ```

4. **`calBind()`**

   - `calBind` 调用时，`this` 已经被绑定到 `{num1: 100, num2: 200}`。
   - 因此，`this.num1` 是 `100`，`this.num2` 是 `200`。

   ```javascript
   calBind(); // 输出 300
   ```

#### 总结

- `new cal()` 输出：`NaN`
- `cal()` 输出：`3`
- `new calBind()` 输出：`NaN`
- `calBind()` 输出：`300`

这是因为 `this` 在每种调用方式下的指向不同，影响了对 `num1` 和 `num2` 的访问。

### **JS29** **全选**

请补全JavaScript代码，实现以下效果：

1. 选中"全选"框，以下所有选项全部勾选。
2. 把"全选"框从选中状态勾选成未选中状态，其他复选框全部取消选中效果。
3. 当其他复选框全部选中，"全选框"为选中状态。
4. 当其他复选框有一个未选中，"全选框"取消选中状态。

注意：

1. 必须使用DOM0级标准事件（onchange）

~~~js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
</head>
<style>
    ul {
        list-style: none;
    }
</style>

<body>

    <ul>
        <li>全选<input type='checkbox' id='all'></li>
        <li>Java<input type='checkbox' class='item'></li>
        <li>javaScript<input type='checkbox' class='item'></li>
        <li>C++<input type='checkbox' class='item'></li>
        <li>python<input type='checkbox' class='item'></li>
        <li>.net<input type='checkbox' class='item'></li>
    </ul>

    <script>
        // 补全代码
            var  all = document.querySelector('#all')

            var  options = Array.from(document.querySelectorAll('.item'))

            all.onchange= ()=>{
                options.forEach(x=>x.checked = all.checked)
            }

            options.forEach(item=>{
                item.onchange = () =>{
                    all.checked = options.every(x=>x.checked)
                }
            })

    </script>
</body>

</html>

~~~

### **Proxy计数器**

请补全JavaScript代码，请给参数对象添加拦截代理功能，并返回这个代理，要求每当通过代理调用该对象拥有的属性时，"count"值加1，否则减1。

~~~js
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Proxy Example</title>
</head>
<body>
     <!-- // 示例对象
        const myObject = { a: 1, b: 2 };

        // 使用 _proxy 函数创建 myObject 的代理
        const proxiedObject = _proxy(myObject);

        // 访问属性并查看计数器的变化
        console.log(proxiedObject.a); // 输出: 1, count 变为 1
        console.log(proxiedObject.b); // 输出: 2, count 变为 2
        console.log(proxiedObject.c); // 输出: undefined, count 变为 1
        console.log(count); // 最终输出: 1 -->
    <!-- Proxy 虽然 是代理，但是本质还是对原对象进行操作，所以要结合Reflect使用，才是真正的不再对原对象进行直接操作
而且Reflect有返回值 -->
    <script type="text/javascript">
        // 初始化计数器
        let count = 0;

        // 定义一个函数，用于创建对象的代理
        const _proxy = object => {
            // 创建代理对象，拦截对原始对象的操作
            const objectProxy = new Proxy(object, {
                // 拦截对属性的获取操作
                get(target, prop, receiver) {
                    // 尝试从原始对象中获取属性值
                    const isSuccss = Reflect.get(target, prop, receiver);

                    // 如果属性存在于目标对象中
                    if (prop in target) {
                        count++; // 增加计数器
                    } else {
                        count--; // 减少计数器
                    }

                    // 返回获取的属性值
                    return isSuccss;
                }
            });
            // 返回代理对象
            return objectProxy;
        }
 
      
    </script>
</body>
</html>

~~~

### 获取页面所有a标签，判断链接的协议是否是https

~~~js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Check HTTPS Links</title>
</head>
<body>
    <a href="https://example.com">Example HTTPS</a>
    <a href="http://example.com">Example HTTP</a>
    <a href="#section">Internal Link</a>

    <script>
        document.querySelectorAll('a').forEach(anchor => {
            if (anchor.href.startsWith('https://')) {
                console.log(`${anchor.href} uses HTTPS`);
            } else {
                console.log(`${anchor.href} does not use HTTPS`);
            }
        });
    </script>
</body>
</html>

~~~

### 敏感信息隐藏

~~~js
// 将字符串中间四个字符隐藏为传入的字符，默认为*
// 1. 字符串长度小于等于4，返回字符串长度对应的*，如"1234" => "****"
// 2. 若字符串长度为奇数，隐藏中间四个字符，多出来的一个数放后面，如"123456789" => "12****789"
// 3. 若字符串长度为偶数，隐藏中间四个字符，如"12345678" => "12****78"

//方法一：直接寻找字符串的需要修改的地方，进行截取拼接
function hideMiddleChars(str, hideChar = '*') {
    const len = str.length;
    
    if (len <= 4) {
        return hideChar.repeat(len);
    }
    
    const middleIndex = Math.floor(len / 2); // 中间位置索引
    
    // 获取隐藏的前后各两位字符的位置
    const start = middleIndex - 2;
    const end = middleIndex + 2;
    
    // 拼接隐藏中间四个字符的字符串
    const hiddenStr = str.substring(0, start) + hideChar.repeat(4) + str.substring(end);
    
    return hiddenStr;
}
//方法二：转换为数组，使用瑞士军刀splice
function hideMiddleChars(str, hideChar = '*') {
    const len = str.length;
    if (len <= 4) {
        return hideChar.repeat(len);
    }
    // 将字符串转换为数组
    let strArr = str.split('');
    const middleIndex = Math.floor(len / 2);
    // 确定起始和结束位置
    const start = middleIndex - 2;
    
    // 使用 splice 替换中间四个字符为 hideChar
    strArr.splice(start, 4, ...Array(4).fill(hideChar));
    
    // 将数组重新拼接成字符串
    const hiddenStr = strArr.join('');
    
    return hiddenStr;
}

console.log(hideMiddleChars("1234")); // "****"
console.log(hideMiddleChars("123456789")); // "12****789"
console.log(hideMiddleChars("12345678")); // "12****78"
console.log(hideMiddleChars("123456")); // "1****6"
console.log(hideMiddleChars("1")); // "*"
console.log(hideMiddleChars("12")); // "**"
console.log(hideMiddleChars("123")); // "***"
console.log(hideMiddleChars("1234567")); // "1****67"
~~~

### **Proxy拦截器**

描述

请补全JavaScript代码，请给参数对象添加拦截代理功能并返回这个代理。要求如下：

1. 该函数接收多个参数，首个参数为对象，从第二个参数（包括）往后皆是该对象的属性名
2. 通过该函数给首个参数对象添加拦截器功能，每当该对象访问到该函数第二个参数（包括）往后的属性时，返回"noright"字符串，表示无权限。

~~~js
<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
    </head>
    <body>

        <script type="text/javascript">
            const _proxy = (object,...prototypes) => {
                // 补全代码
                return new Proxy(object,{
                    get(target,prop){
                        if(prototypes.includes(prop)) return 'noright';
                        return object[prop];
                    }
                })
            }
        </script>
    </body>
</html>
~~~

### **监听对象**

请补全JavaScript代码，要求如下：

1. 监听对象属性的变化
2. 当"person"对象的属性发生变化时，页面中与该属性相关的数据同步更新

注意：

1. 必须使用Object.defineProperty实现且触发set方法时更新视图
2. 可以使用预设代码"_render"函数

解：

1. 创建”Observe“函数，接收一个对象参数，首先判断该对象参数是否合法，之后通过遍历对象的所有属性进行拦截操作。尽管可以直接使用Object.defineProperty函数对”person“对象进行拦截，但是可以通过创建”Observe“函数来封装对某个对象的属性劫持功能，之后可以复用此函数。
2. 创建“defineReactive”函数，接收三个参数分别为该对象、对象属性、对象属性值。该函数内部使用Object.defineProperty函数对该对象的属性值进行拦截，且每当触发set时，调用”render“方法重新渲染视图

~~~js
function Observe(target) {
    if (typeof target !== 'object' || target == null) {
        return target
    }
    for (var key in target) {
        defineReactive(target, key, target[key])
    }
}
function defineReactive(target, key, value) {
    Object.defineProperty(target, key, {
        get: function () {
            return value
        },
        set: function (newVal) {
            if (newVal !== value) {
                value = newVal
                _render(ul)
            }

        }

    })
}
Observe(person)

~~~

### promise的调用

请问以下JS代码输出的结果是（）

```
const p1 = Promise.resolve(117);
const p2 = Promise.resolve(p1);
const p3 = Promise.resolve(117);
console.log(p1 == p2,p1 === p2,p1 === p3);
```

1. **`const p1 = Promise.resolve(117);`**
   - 这行代码创建了一个 `p1` 的 Promise 对象，它会立即以值 `117` 进行解析。
   - `p1` 是一个 Promise 对象。
2. **`const p2 = Promise.resolve(p1);`**
   - 这行代码使用 `Promise.resolve(p1)` 创建了另一个 Promise 对象 `p2`。
   - 如果 `Promise.resolve` 接收到一个 Promise 对象，它会直接返回这个相同的 Promise 对象。因此，`p2` 和 `p1` 是相同的对象。
3. **`const p3 = Promise.resolve(117);`**
   - 这行代码创建了另一个 Promise 对象 `p3`，它也会被解析为值 `117`。
   - 尽管 `p1` 和 `p3` 都是解析为相同的值 `117`，但它们是不同的 Promise 对象。
4. **`console.log(p1 == p2, p1 === p2, p1 === p3);`**
   - `p1 == p2`: 检查 `p1` 和 `p2` 是否是相同的对象，由于 `p2` 就是 `p1`，因此结果为 `true`。
   - `p1 === p2`: 这同样检查 `p1` 和 `p2` 是否严格相等，结果仍为 `true`。
   - `p1 === p3`: 虽然 `p1` 和 `p3` 都是被解析为值 `117`，但它们是不同的 Promise 对象，因此结果为 `false`。

最终输出

因此，`console.log(p1 == p2, p1 === p2, p1 === p3);` 的输出将是：`true true false`。



### flex布局

需要实现一个左侧宽度固定，右侧元素自适应，应该在下面代码中补充哪个选项（）

<div class="container">

<div class="fixed-width">固定宽度</div>

<div class="flexible-width">自适应宽度</div>

~~~
</div>

.container {

display: flex;

}

.fixed-width {

width: 200px; /* 左边元素的固定宽度 */

}

.flexible-width {
  flex: 1;
   //或者flex-grow: 1; /* 右侧元素自适应宽度 */
}

~~~

### 实现二叉树找最大值

要在 JavaScript 中实现一个二叉树的最大值查找，你可以使用递归遍历的方式来查找二叉树中的最大值。以下是一个示例实现：

1. 定义二叉树节点结构：

首先，我们定义一个二叉树的节点结构，每个节点包含一个值以及指向其左、右子节点的引用。

```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}
```

2. 构建查找最大值的函数：

接下来，我们实现一个函数 `findMaxValue`，这个函数通过递归遍历二叉树来查找最大值。

```javascript
function findMaxValue(root) {
    // 如果当前节点为空，返回负无穷大，表示在这一支没有找到有效节点
    if (root === null) {
        return -Infinity;
    }

    // 递归查找左子树和右子树的最大值
    const leftMax = findMaxValue(root.left);
    const rightMax = findMaxValue(root.right);

    // 返回当前节点值、左子树最大值、右子树最大值中的最大值
    return Math.max(root.value, leftMax, rightMax);
}
```

3. 示例使用：

我们可以通过构建一个简单的二叉树并调用 `findMaxValue` 函数来查找该树中的最大值。

```javascript
// 构建一个简单的二叉树
let root = new TreeNode(3);
root.left = new TreeNode(1);
root.right = new TreeNode(5);
root.left.left = new TreeNode(0);
root.left.right = new TreeNode(2);
root.right.left = new TreeNode(4);
root.right.right = new TreeNode(6);

// 查找二叉树中的最大值
let maxValue = findMaxValue(root);
console.log("The maximum value in the binary tree is:", maxValue);
```

4. 输出结果：

在这个例子中，二叉树结构如下：

```
      3
     / \
    1   5
   / \ / \
  0  2 4  6
```

运行这段代码后，输出结果将是：

```
The maximum value in the binary tree is: 6
```

解释：

- 递归遍历二叉树，分别计算左右子树的最大值，并比较当前节点值与左右子树的最大值。
- 最终得到的结果是整个二叉树中的最大值。

### js 寻找字符串中出现最多的字符怎么实现

~~~
function findMostFrequentChar(str) {
    // 创建一个对象来保存每个字符的出现次数
    let charCount = {};

    // 遍历字符串，统计每个字符的出现次数
    for (let char of str) {
        if (charCount[char]) {
            charCount[char]++;
        } else {
            charCount[char] = 1;
        }
    }

    // 初始化最大次数和对应的字符
    let maxCount = 0;
    let maxChar = '';

    // 遍历统计结果，找到出现次数最多的字符
    for (let char in charCount) {
        if (charCount[char] > maxCount) {
            maxCount = charCount[char];
            maxChar = char;
        }
    }

    // 返回出现次数最多的字符
    return { character: maxChar, count: maxCount };
}

// 测试
let str = "javascript";
let result = findMostFrequentChar(str);
console.log(`The most frequent character is '${result.character}' with ${result.count} occurrences.`);

~~~

 ![image-20240815123422432](http://battle.wicp.io:9001/blog1/202408202215409.png)



### **合并k个已排序的链表**

合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。

数据范围：节点总数 0≤n≤50000≤*n*≤5000，每个节点的val满足 ∣val∣<=1000∣*v**a**l*∣<=1000

要求：时间复杂度 O(nlogn)

示例2

输入：

```
[{1,2},{1,4,5},{6}]
```

复制

返回值：

```
{1,1,2,4,5,6}
```

~~~js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here

    if(lists.length <=1) return lists[0] || null ;
    return merge(lists,0,lists.length);
}

function merge(lists,l,r){
    if(l>r)  return null ;
    if(l==r) return lists[l];
    const mid =Math.floor((l+r)/2);
    return mergeTwolist(merge(lists,l,mid),merge(lists,mid+1,r));//返回 的是一个排好序的list
}

function mergeTwolist(list1,list2){
    if(!list1||!list2) return list1||list2;
    let p1= list1,p2= list2,head = {next:null},p= head;
    while(p1&&p2){
        if(p1.val>p2.val){
            p.next= p2;
            p2=p2.next;
        }else{
            p.next = p1;
            p1=p1.next;

        }
        p=p.next;
    }
    p.next=p1||p2;
    return head.next;

}
module.exports = {
    mergeKLists : mergeKLists
};
~~~

### **判断链表中是否有环**

输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。

例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：

![img](http://battle.wicp.io:9001/blog1/202408202215410.png)

可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。

###### 示例1

输入：

```
{3,2,0,-4},1
```

返回值：

```
true
```

说明：

```
第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4->2存在一个链接，组成传入的head为一个带环的链表，返回true      
```

~~~js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here

    while(head){
        if(head.flag) return true;
        head.flag =true;
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
~~~

### 二分查找

请实现无重复数字的升序数组的二分查找

给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1

输入：

```
[-1,0,3,4,6,10,13,14],13
```

返回值：

```
6
```

说明：

```
13 出现在nums中并且下标为 6     
```

~~~
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
 */
function search( nums ,  target ) {
    // write code here
    let len = nums.length ;
    if(!len) return -1;
    let [left,right] = [0,len-1];
    while(left<=right){
        let mid = left +Math.floor((right-left)/2);
        let num =nums[mid];
        if(num === target) return mid;
        else if (num >target) right = mid-1;
        else left = mid +1;


    }
    return -1;

}
module.exports = {
    search : search
};
~~~



### 判断 对称二叉树

 对称二叉树，是一种二叉树，具有对称的性质，如： 

​      1  

​     /  \  

​    2   2  

​    / \   / \  

   3  4 4  3  

   现在给定一个二叉树的根节点，节点存储的值为整型数，请实现一个算法判断该二叉树是否为对称二叉树

~~~
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function isMirrorTree(root) {
    if (!root) return true; // 如果树为空，直接返回true
    return checkMirror(root.left, root.right);
}

function checkMirror(left, right) {
    // 如果两个节点相同（都是null），返回true
    if (left === right) return true;

    // 如果其中一个节点是null，或者两个节点值不同，返回false
    if (left === null || right === null || left.val !== right.val) return false;

    // 递归检查左子树和右子树是否对称
    return checkMirror(left.left, right.right) && checkMirror(left.right, right.left);
}

// 示例：
// 构造一个简单的镜像二叉树
let root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(2);
root.left.left = new TreeNode(3);
root.left.right = new TreeNode(4);
root.right.left = new TreeNode(4);
root.right.right = new TreeNode(3);

console.log(isMirrorTree(root)); // 输出 true

~~~

## **链表中环的入口结点**

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。
输入描述：输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这2个会组装成一个有环或者无环单链表
返回值描述：返回链表的环的入口结点即可。而我们后台程序会打印这个节点
示例1
输入：{1,2},{3,4,5}
返回值：3
说明：返回环形链表入口节点，我们后台会打印该环形链表入口节点，即3

通过定义slow和fast指针，slow每走一步，fast走两步，若是有环，则一定会在环的某个结点处相遇（slow == fast），根据下图分析计算，可知从相遇处到入口结点的距离与头结点与入口结点的距离相同。
![图片说明](http://battle.wicp.io:9001/blog1/202408202215411.png)

~~~js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
//定义快慢指针,感觉像是数学题
let fast = pHead;
let slow = pHead;

while(slow!=null && fast != null &&fast.next != null ){
    fast = fast.next.next;
    slow= slow.next;
    if(fast == slow){
        let p =pHead;
        while(p!=slow){
            p= p.next;
            slow = slow.next;
        }
        return p;
    }
}
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};

~~~

## 寻找峰值

~~~
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param nums int整型一维数组
 * @return int整型
 */
function findPeakElement(nums) {
    // write code here
    let peakIndx = -1;
    let len = nums.length
    peakIndx = binarySearch(0, len - 1);
    function binarySearch(left, right) {
        const mid = Math.floor((left + right) / 2);
        if (left === right) {
            return mid;
        }
        //判断mid右边是不是向上区间
        if (nums[mid + 1] > nums[mid]) {
            //右边是右向上区间，
            // mid不可能是峰值 所以+1，继续+1收缩找到上区间的分界线和下区间
            left = mid + 1;
        } else {
            // 如果右边是向下区间就往左收缩
            //不-1是因为mid可能是峰值，
            //             收缩之后如果left === right就是mid就是峰值
            right = mid;
        }
        return binarySearch(left, right);
    }
    return peakIndx;
}
module.exports = {
    findPeakElement: findPeakElement,
};

~~~

## 前序遍历

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return int整型一维数组
 */
function preorderTraversal( root ) {
    // write code here
     const res = [];
    preorder(root,res)
    return res;
}
function preorder(root,res) {
    if(root == null) {
       return;
    }
    // 前序遍历的位置
    res.push(root.val)
    preorder(root.left,res)
    preorder(root.right,res)
}

module.exports = {
    preorderTraversal : preorderTraversal
};
~~~

## **二叉树的最大深度**

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return int整型
 */
function maxDepth( root ) {
    // write code here
    return preorder(root);
}

function preorder(root){
    //前序遍历中判断最大深度
    //叶子节点null+1
    if(root==null) return 0;
    return Math.max(preorder(root.left),preorder(root.right))+1;
}
module.exports = {
    maxDepth : maxDepth
};
~~~

## **二叉搜索树与双向链表**

~~~
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function Convert(pRootOfTree)
{
    // write code here

     let head = null;
    let pre = null;
    function MediumOrderDFS (cur) {
        if(cur === null) {
            return;
        }
        // 递归左结点
        MediumOrderDFS(cur.left);
        // 处理当前结点
        if(pre === null) {
            head = cur;
        } else {
            pre.right = cur;
        }
        cur.left = pre;
        pre = cur;
        // 遍历右结点//
        MediumOrderDFS(cur.right);
    }
    MediumOrderDFS(pRootOfTree);
    return head;
}
module.exports = {
    Convert : Convert
};
~~~

## 按位置 **合并二叉树**

~~~
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param t1 TreeNode类 
 * @param t2 TreeNode类 
 * @return TreeNode类
 */
function mergeTrees( t1 ,  t2 ) {
    // write code here
    if(t1&&t2){
        t1.val+=t2.val;
        t1.left = mergeTrees(t1.left,t2.left);
        t1.right = mergeTrees(t1.right,t2.right);
    }
    return t1||t2;
}


module.exports = {
    mergeTrees : mergeTrees
};
~~~

## **链表中倒数最后k个结点**

~~~
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( pHead ,  k ) {
    // write code here
    //我称之为追赶法
    let [s,f]=[pHead,pHead];
    while(f!=null && k>0){
        f= f.next;
        k--;
    }

    if(k>0) return null;
    while(f!=null){
        s=s.next;
        f=f.next;
    }
    return s;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
~~~





## **两个链表的第一个公共结点**

~~~
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    let s= new Set();

    while(pHead1!==null){
        s.add(pHead1);
        pHead1=pHead1.next;
    }

    while(pHead2!=null){
        if(s.has(pHead2)){
            return pHead2;
        }
        pHead2=pHead2.next;
    }

    return null;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
~~~

//、/、、、
